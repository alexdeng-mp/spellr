#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
class RubyWords
  def initialize
    @strings = []
    prepare_excluded_classes

    parse_options

    prepare_post_excluded_classes

    puts get_words
  end

  private

  def prepare_excluded_classes
    @looked_at = []
    @looked_at << RubyWords.__id__
    @looked_at << OptionParser.__id__ # because we're including it here
  end

  def get_words
    $VERBOSE=nil
    @strings = []
    get_words_for(Module)
    get_keywords
    get_convention_words
  end

  def get_words_for(constant)
    return if @looked_at.include?(constant.__id__) # to prevent endless loops

    @looked_at << constant.__id__

    get_methods_for(constant)
    get_child_constants_for(constant)
  end

  def get_methods_for(constant)
    @strings |= constant.public_instance_methods(false) if constant.respond_to?(:public_instance_methods)
    @strings |= constant.public_methods(false) if constant.respond_to?(:public_methods)
  end

  def get_child_constants_for(constant)
    return unless constant.respond_to?(:constants)

    constant.constants.each do |child|
      if autoload?(child)
        $stderr.puts "Skipping autoload constant #{constant}::#{child}"
        next
      end

      @strings |= [child]
      child = constant.const_get(child)
      get_words_for(child)
    rescue StandardError, LoadError => e
      $stderr.puts "Error loading #{constant}::#{child} => #{e.message}"
    end
  end

  def get_keywords
    @strings |= %w{
      __ENCODING__ __LINE__ __FILE__ BEGIN END alias and begin break case class def
      defined? do else elsif end ensure false for if in module next nil not or redo
      rescue retry return self super then true undef unless until when while yield
    }
  end

  def get_convention_words
    @strings |= %w{
      klass
    }
  end

  # badly behaved classes that I'll always have to exclude
  # TODO: use the full class name rather than __id__ so i don't have to load anything
  def prepare_post_excluded_classes
    %w{RSpec::Core::Runner I18n::Tests}.each do |exclude|
      @looked_at << Module.const_get(exclude).__id__
    rescue StandardError, LoadError
    end
  end

  def exclude_option(excludes, quiet: false)
    excludes.each do |exclude|
      @looked_at << Module.const_get(exclude).__id__
    rescue StandardError, LoadError => e
      $stderr.puts "Error excluding #{exclude} => #{e.message}" unless quiet
    end
  end

  def bundler_option(_)
    require 'bundler/setup'
    require_each Bundler.setup.requires.values.flatten(1)
  end

  def require_each(requirables)
    requirables.each(&method(:soft_require))
  end

  def soft_require(requireable)
    require requireable
  rescue LoadError => e
    $stderr.puts "Error requiring #{requireable} => #{e.message}"
  end

  def require_option(gems)
    soft_require 'bundler/setup'
    require_each(gems)
  end

  def available_stdlibs
    %w{
      abbrev base64 benchmark bigdecimal cgi cmath coverage csv date delegate digest
      drb/drb e2mmap English erb etc expect fcntl fiddle fileutils find forwardable
      getoptlong io/console io/nonblock io/wait ipaddr irb json logger matrix mkmf
      monitor mutex_m net/ftp net/http net/imap net/pop net/smtp net/telnet nkf
      objspace observer open-uri open3 openssl optionparser optparse ostruct pathname
      pp prettyprint prime pstore psych pty racc/parser readline resolv ripper rss scanf
      sdbm securerandom set shell shellwords singleton socket stringio strscan sync syslog
      tempfile thwait time timeout tmpdir tracer tsort uri weakref webrick yaml zlib
    }
  end

  def stdlib_option(stdlibs)
    stdlibs = stdlibs & available_stdlibs
    stdlibs.each { |p| require p }
    @strings += stdlibs
    @looked_at -= [OptionParser.__id__] if stdlibs.include?('optparse') # because they might want it too
  end

  def parse_options
    OptionParser.new do |opts| # rubocop:disable Metrics/BlockLength
      opts.set_program_name 'spellr --fetch ruby'

      opts.on('-r', '--require=x,y,z', Array, 'requires the specified gems', &method(:require_option))
      opts.on('-s', '--stdlib=x,y,z', Array, 'requires the specified stdlib packages', &method(:stdlib_option))
      opts.on('-b', '--bundler', 'includes methods and constants required by emfile', &method(:bundler_option))
      opts.on('-x', '--exclude=x,y,z', Array, 'exclude listing these constants and their methods', &method(:exclude_option))
      opts.on_tail('-h', '--help', 'Shows this message') do
        $stderr.puts opts
        exit 1
      end
    end.parse!
  end
end

RubyWords.new
