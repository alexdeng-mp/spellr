#!/usr/bin/env ruby
# frozen_string_literal: true

@looked_at = []
@strings = []

stdlib = ARGV.include?('--with-stdlib')
bundler = ARGV.include?('--with-bundler')

if stdlib
  stdlib = %w{
    abbrev base64 benchmark bigdecimal cgi cmath coverage csv date delegate digest
    drb/drb e2mmap English erb etc expect fcntl fiddle fileutils find forwardable
    getoptlong io/console io/nonblock io/wait ipaddr irb json logger matrix mkmf
    monitor mutex_m net/ftp net/http net/imap net/pop net/smtp net/telnet nkf
    objspace observer open-uri open3 openssl optionparser optparse ostruct pathname
    pp prettyprint prime pstore psych pty racc/parser readline resolv ripper rss scanf
    sdbm securerandom set shell shellwords singleton socket stringio strscan sync syslog
    tempfile thwait time timeout tmpdir tracer tsort uri weakref webrick yaml zlib
  }

  stdlib.each { |p| require p }

  @strings = stdlib.map(&:to_sym) # because you do have to require them by those names
end

if bundler
  require 'bundler/setup'
  Bundler.require(:default)
  Bundler.require(:development)
end

private

def get_everything(parent)
  return if @looked_at.include?(parent.__id__) # to prevent endless loops

  @looked_at << parent.__id__

  @strings |= parent.public_instance_methods(false) if parent.respond_to?(:public_instance_methods)
  @strings |= parent.public_methods(false) if parent.respond_to?(:public_methods)

  return unless parent.respond_to?(:constants)

  parent.constants.each do |c|
    @strings |= [c]
    c = parent.const_get(c)
    get_everything(c)
  end
end

get_everything(Module)

require_relative '../lib/spellr'

Spellr::Dictionary::DEFAULT_DIR
  .join("ruby#{'.stdlib' if stdlib}#{'.bundler' if bundler}.txt")
  .write(Spellr::Token.tokenize(@strings.uniq.join("\n")).map { |w| w.to_s.downcase }.sort.uniq.join("\n"))
